/*
  Buttercup compiler - WebAssembly text file (Wat) code generator.
  Copyright (C) 2020-2021 Ariel Ortiz, ITESM CEM

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Drac {

    class WatVisitor {

        int labelCounter = 0;
        public WatVisitor() {
        }

        public string Visit(Program node)
        {
            // stringCode.Append(";; Generated by the drac compiler "
            //     + "(module\n");
            // stringCode.Append($"\t\t(import \"drac\" \"printi\" (func $printi (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"printc\" (func $printc (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"prints\" (func $prints (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"println\" (func $println (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"readi\" (func $readi (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"reads\" (func $reads (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"new\" (func $new (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"size\" (func $size (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"add\" (func $add (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"get\" (func $get (param i32) (result i32)))\n");
            //  stringCode.Append($"\t\t(import \"drac\" \"set\" (func $set (param i32) (result i32)))\n");
            return ";; WebAssembly text format code generated by "
                + "the drac compiler.\n\n"
                + "(module\n"
                + "\t(import \"drac\" \"printi\" (func $printi (param i32) (result i32)))\n"
                + "\t(import \"drac\" \"printc\" (func $printc (param i32) (result i32)))\n"
                + "\t(import \"drac\" \"prints\" (func $prints (param i32) (result i32)))\n"
                + "\t(import \"drac\" \"println\" (func $println (result i32)))\n"
                + "\t(import \"drac\" \"readi\" (func $readi (result i32)))\n"
                + "\t(import \"drac\" \"reads\" (func $reads (result i32)))\n"
                + "\t(import \"drac\" \"new\" (func $new (param i32) (result i32)))\n"
                + "\t(import \"drac\" \"size\" (func $size (param i32) (result i32)))\n"
                + "\t(import \"drac\" \"add\" (func $add (param i32 i32) (result i32)))\n"
                + "\t(import \"drac\" \"get\" (func $get (param i32 i32) (result i32)))\n"
                + "\t(import \"drac\" \"set\" (func $set (param i32 i32 i32) (result i32)))\n\n"
                + VisitChildren(node)
                + "\t\ti32.const 0\n"
                + "\t)\n"
                + ")\n";
        }

        public string Visit(VarDef node){
            return VisitChildren(node);
        }

        public string Visit(VarDefList node){
            return VisitChildren(node);
        }

        public string Visit(Identifier node)
        {
            return VisitChildren(node);
        }

        public string Visit(IdList node)
        {
            return VisitChildren(node);
        }
        public string Visit(Funcion node){
            var stringCode = new StringBuilder();
            var functionName = node.AnchorToken.Lexeme;

            if (functionName.Contains("main"))
            {
                stringCode.Append($"\t(func\n" + $"\t\t(export \"{functionName}\")\n");
                stringCode.Append("\t\t(result i32)\n");
                stringCode.Append("\t\t(local $_temp i32)\n");
                stringCode.Append("\t\t(local $s i32)\n");
                stringCode.Append(Visit((dynamic) node[2]));
            }
            return stringCode.ToString();

        }

        public string Visit(ExprList node)
        {
            return VisitChildren(node);
        }
        public string Visit(StmtList node)
        {
            return VisitChildren(node);
        }

        public string Visit(Assignment node){
            return VisitChildren(node);
        }

        public string Visit(FunctionCall node) {
            return Visit((dynamic) node[0])
                + $"\t\tcall ${node.AnchorToken.Lexeme}\n\t\tdrop\n";
        }

        public string Visit(Increase node){
            return VisitChildren(node);
        }

        public string Visit(Decrease node){
            return VisitChildren(node);
        }

        public string Visit(StmtIf node){
            return VisitChildren(node);
        }

        public string Visit(ElseIfList node){
            return VisitChildren(node);
        }

        public string Visit(ElseIf node){
            return VisitChildren(node);
        }

        public string Visit(Else node){
            return VisitChildren(node);
        }

        public string Visit(StmtWhile node){
            var label1 = GenerateLabel();
            var label2 = GenerateLabel();

            return "block" + label1 + "\n"
            + "loop" + label2 + "\n"
            + Visit((dynamic) node[0])
            + "i32.eqz\n"
            + "br_if" + label1 + "\n"
            + Visit ((dynamic) node[1])
            + "br" + label2 + "\n"
            + "end\n"
            + "end\n";
        }

        public string Visit(StmtDoWhile node){
            var label1 = GenerateLabel();
            var label2 = GenerateLabel();

            return "block" + label1 + "\n"
            + "loop" + label2 + "\n"
            + Visit ((dynamic) node[1])
            + Visit((dynamic) node[0])
            + "i32.eqz\n"
            + "br_if" + label1 + "\n"
            + "br" + label2 + "\n"
            + "end\n"
            + "end\n";
        }

        public string Visit(StmtBreak node){
            return VisitChildren(node);
        }

        public string Visit(StmtReturn node)
        {
            return  VisitChildren(node) + "\t\treturn\n";
        }

        public string Visit(StmtEmpty node){
            return VisitChildren(node);
        }

        public string Visit(Equals node){
            return VisitChildren(node);
        }

        public string Visit(Diff node){
            return VisitChildren(node);
        }

        // public string Visit(Less node) {
        //     return VisitBinaryOperator("i32.lt_s", node);
        // }

        public string Visit(LessEqual node){
            return VisitChildren(node);
        }

        public string Visit(Greater node){
            return VisitChildren(node);
        }

        public string Visit(MoreEqual node){
            return VisitChildren(node);
        }

        public string Visit(Neg node) {
            return "    i32.const 0\n"
                + Visit((dynamic) node[0])
                + "    i32.sub\n";
        }

        // public string Visit(Plus node) {
        //     return VisitBinaryOperator("i32.add", node);
        // }

        // public string Visit(Mul node) {
        //     return VisitBinaryOperator("i32.mul", node);
        // }

        public string Visit(Div node){
            return VisitChildren(node);
        }

        public string Visit(Mod node){
            return VisitChildren(node);
        }

        public string Visit(Not node){
            return VisitChildren(node);
        }

        public string Visit(Positive node){
            return VisitChildren(node);
        }

        public string Visit(Negative node){
            return VisitChildren(node);
        }

        public string Visit(True node) {
            return "    i32.const 1\n";
        }

        public string Visit(False node) {
            return "    i32.const 0\n";
        }

        public string Visit(Int_literal node)
        {
            return $"\t\ti32.const {node.AnchorToken.Lexeme}\n";
        }

        public string Visit(Char_lit node){
            return VisitChildren(node);
        }

        public string Visit(String_lit node){
            var asciiChars = convertCharToASCII(node.AnchorToken.Lexeme);
            var sb = new StringBuilder();
            sb.Append("\t\ti32.const 0\n");
            sb.Append("\t\tcall $new\n");
            sb.Append($"\t\tlocal.set $_temp\n");
            foreach (var entry in asciiChars)
            {
                sb.Append($"\t\tlocal.get $_temp\n");
            }
            sb.Append($"\t\tlocal.get $_temp\n");
            foreach (var entry in asciiChars){
                sb.Append($"\t\ti32.const {entry}\n"
                          + "\t\tcall $add\n"
                          + "\t\tdrop\n");
            }
            return sb.ToString();
        }

        public string Visit(Or node){
            return VisitChildren(node);
        }

        // public string Visit(And node) {
        //     return VisitBinaryOperator("i32.and", node);
        // }

        public string Visit(Array node){
            return VisitChildren(node);
        }

        string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }

        public String GenerateLabel(){
            return $"${labelCounter++:00000}";
        }

        private IList<int> convertCharToASCII(String Lexeme){
            var result = new List<int>();
            for (int i = 0; i < Lexeme.Length; i++)
            {
                int asciiChar = (int)Lexeme[i];
                if(asciiChar != 34 && asciiChar != 39){
                    if(asciiChar == 92){
                        i++;
                        switch((int)Lexeme[i]){
                            case 34:
                                result.Add(34);
                                break;
                            case 39:
                                result.Add(39);
                                break;
                            case 92:
                                result.Add(92);
                                break;
                            case 110:
                                result.Add(10);
                                break;
                            case 114:
                                result.Add(13);
                                break;
                            case 116:
                                result.Add(9);
                                break;
                        }
                    }else{
                        result.Add(asciiChar);
                    }
                }
            }
            return result;
        }
    }
}
